{"version":3,"sources":["assets/images/bolt.png","assets/images/arrow.svg","assets/images/qrcode.png","assets/images/github.svg","lib/bolt11.js","constants/keys.js","utils/keys.js","utils/invoices.js","app.js","utils/internet-identifier.js","constants/app.js","index.js","assets/images/close.svg"],"names":["module","exports","crypto","require","bech32","secp256k1","Buffer","BN","bitcoinjsAddress","cloneDeep","coininfo","BITCOINJS_NETWORK_INFO","bitcoin","main","toBitcoinJS","testnet","test","regtest","simnet","litecoin","litecoin_testnet","DEFAULTNETWORK","VALIDWITNESSVERSIONS","BECH32CODES","bc","tb","bcrt","sb","ltc","tltc","DIVISORS","m","u","n","p","MAX_MILLISATS","MILLISATS_PER_BTC","MILLISATS_PER_MILLIBTC","MILLISATS_PER_MICROBTC","MILLISATS_PER_NANOBTC","PICOBTC_PER_MILLISATS","TAGCODES","payment_hash","description","payee_node_key","purpose_commit_hash","expire_time","min_final_cltv_expiry","fallback_address","routing_info","TAGNAMES","i","keys","Object","length","currentName","currentCode","toString","TAGENCODERS","hexToWord","text","buffer","from","textToBuffer","toWords","data","undefined","String","Error","match","sha256","intBEToWords","network","code","concat","addressHash","datas","forEach","hexToBuffer","pubkey","short_channel_id","fee_base_msat","slice","fee_proportional_millionths","cltv_expiry_delta","TAGPARSERS","words","wordsToBuffer","wordsToIntBE","version","address","toBase58Check","pubKeyHash","scriptHash","toBech32","shortChannelId","feeBaseMSats","feeProportionalMillionths","cltvExpiryDelta","routes","routesBuffer","parseInt","push","getUnknownParser","tagCode","encode","Number","MAX_SAFE_INTEGER","reverse","reduce","total","item","index","Math","pow","intBE","bits","floor","createHash","update","digest","convert","inBits","outBits","value","maxV","result","trim","hex","tagsItems","tags","tagName","tag","filter","tagsContainItem","orderKeys","unorderedObj","orderedObj","sort","key","satToHrp","satoshis","millisatToHrp","mul","millisatoshis","divisorString","valueString","millisatoshisBN","millisatoshisString","millisatoshisLength","div","hrpToSat","hrpString","outputString","hrpToMillisat","mod","eq","divisor","valueBN","gt","inputData","addDefaults","coinTypeObj","nodePublicKey","tagNodePublicKey","canReconstruct","signature","recoveryFlag","coinType","timestamp","Date","getTime","payeeNodeKey","equals","addrData","bech32addr","base58addr","fromBech32","e","fromBase58Check","hash","f","prefix","route","publicKeyVerify","shortId","timestampWords","tagWords","possibleTagNames","indexOf","encoder","decode","unknownEncoder","sigWords","dataWords","payReqHash","recoveredPubkey","recover","timeExpireDate","timeExpireDateString","toISOString","timestampString","paymentRequest","complete","wordsTemp","toLowerCase","decoded","wordsNoSig","sigBuffer","prefixMatches","coinNetwork","bech32Prefix","removeSatoshis","parser","tagLength","sigPubkey","finalResult","assign","sign","inputPayReqObj","inputPrivateKey","payReqObj","privateKey","privateKeyVerify","publicKey","publicKeyCreate","sigObj","recovery","formatDetailsKey","handleLNURL","invoice","decodedLNURL","url","fromWords","fetch","encodeURIComponent","then","r","json","handleLightningAddress","internetIdentifier","addressArr","split","success","message","username","domain","catch","_","handleBOLT11","includes","LightningPayReq","INITIAL_STATE","error","hasError","decodedInvoice","isLNAddress","isQRCodeOpened","isInvoiceLoaded","isBitcoinAddrOpened","App","PureComponent","state","clearInvoiceDetails","currentOrigin","window","location","origin","history","pushState","this","setState","getInvoiceDetails","async","response","parsedInvoiceResponse","lcInvoice","requestCode","isLNURL","startsWith","parseInvoice","currentUrl","currentPathname","pathname","handleChange","event","target","handleKeyPress","handleQRCode","prevState","renderErrorDetails","className","renderInput","alt","src","boltImage","onChange","onKeyPress","placeholder","autoFocus","renderInvoiceDetails","invoiceContainerClassnames","cx","invoiceDetails","map","renderInvoiceInnerItem","renderInvoiceItem","renderNestedItem","label","renderNestedTag","Array","isArray","renderNormalTag","renderTag","valuePropFormat","renderLogo","renderLNURLDetails","requestContents","random","href","JSON","parse","arrOfData","style","maxWidth","renderSubmit","submitClassnames","onClick","closeImage","arrowImage","renderOptions","optionsClassnames","rel","githubImage","renderCamera","styleQRWrapper","styleQRContainer","styleImgQR","srcImage","qrcodeImage","delay","onError","onScan","is","width","border","componentDidMount","cleanInvoice","render","appClasses","appColumnClasses","appSubmitClasses","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.84ad2638.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/bolt.6f1ab4b1.png\";","module.exports = __webpack_public_path__ + \"static/media/arrow.c97cc055.svg\";","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAytJREFUeJzt3cFuozAUQNHOqP//yzP7LK4VwLEh5+wpNO2VJR4OPz8AAAAAAAAAAAAAE/05eNy/S69i7Oh1cg/b/j/9nXkVcHcCgSAQCAKBIBAIAoEgEAi/k36uuQXvuPr/5bK5ihUEgkAgCASCQCAIBIJAIAgEgkAgCASCQCAIBMKsZ7He9ek9ye86+6zQ7N9v9+s7a9mzfVYQCAKBIBAIAoEgEAgCgSAQCEfnIJ++Lz37fGfnAKPjZ88pZp9/98//1WXXawWBIBAIAoEgEAgCgSAQCAKBsMt+kLNmzwFGVu/HWP1dyKs//2msIBAEAkEgEAQCQSAQBAJBIBCeMgdZfZ/97vsxztr9+g6zgkAQCASBQBAIBIFAEAgEgUC4yxzk7u+vODsnWb3fYvfPfxorCASBQBAIBIFAEAgEgUAQCITHPsf/YavfD+LvOIkVBIJAIAgEgkAgCASCQCAIBMK37Ad5+n6L1ftNVn9+01hBIAgEgkAgCASCQCAIBIJAIOwyB9l9P8Xq489aff6Rba/PCgJBIBAEAkEgEAQCQSAQBAJh9f3vq3z7nGL18SOz9/NMYwWBIBAIAoEgEAgCgSAQCAKBsMscZPZ9/JHZP9/5z51/GSsIBIFAEAgEgUAQCASBQBAIhG3vP7+4+36Hp//81cdPYwWBIBAIAoEgEAgCgSAQCAKBcJc5yMjq/SCrjx95yt/546wgEAQCQSAQBAJBIBAEAkEgEO7ynvSR1e+vmG31+0lWsx8EdiQQCAKBIBAIAoEgEAgCgbDLHGTk6fsldn//xtfOYawgEAQCQSAQBAJBIBAEAkEgEHaZg9z9Pv3o/Lt/b9ZZ277f4ywrCASBQBAIBIFAEAgEgUAQCIRd5iCr7+OPrH4P+cjqOcPq809jBYEgEAgCgSAQCAKBIBAIAoFwdA7y6ef/V++nePp72Ed2n1O9uuzzsIJAEAgEgUAQCASBQBAIBIFAOHp//LHfg8QjmIPAJwgEgkAgCASCQCAIBIJAIAgEgkAgCASCQCDM+m7eq/cwe7br2bbd824FgSAQCAKBIBAIAoEgEAgCAQAAAAAAAAAAOO8/qSxQfUvWAucAAAAASUVORK5CYII=\"","module.exports = __webpack_public_path__ + \"static/media/github.ae2c64de.svg\";","/* eslint-disable */\nconst crypto = require('crypto')\nconst bech32 = require('bech32')\nconst secp256k1 = require('secp256k1')\nconst Buffer = require('safe-buffer').Buffer\nconst BN = require('bn.js')\nconst bitcoinjsAddress = require('bitcoinjs-lib/src/address')\nconst cloneDeep = require('lodash/cloneDeep')\nconst coininfo = require('coininfo')\n\nconst BITCOINJS_NETWORK_INFO = {\n  bitcoin: coininfo.bitcoin.main.toBitcoinJS(),\n  testnet: coininfo.bitcoin.test.toBitcoinJS(),\n  regtest: coininfo.bitcoin.regtest.toBitcoinJS(),\n  simnet: coininfo.bitcoin.regtest.toBitcoinJS(),\n  litecoin: coininfo.litecoin.main.toBitcoinJS(),\n  litecoin_testnet: coininfo.litecoin.test.toBitcoinJS()\n}\nBITCOINJS_NETWORK_INFO.bitcoin.bech32 = 'bc'\nBITCOINJS_NETWORK_INFO.testnet.bech32 = 'tb'\nBITCOINJS_NETWORK_INFO.regtest.bech32 = 'bcrt'\nBITCOINJS_NETWORK_INFO.simnet.bech32 = 'sb'\nBITCOINJS_NETWORK_INFO.litecoin.bech32 = 'ltc'\nBITCOINJS_NETWORK_INFO.litecoin_testnet.bech32 = 'tltc'\n\n// defaults for encode; default timestamp is current time at call\nconst DEFAULTNETWORKSTRING = 'main'\nconst DEFAULTNETWORK = BITCOINJS_NETWORK_INFO[DEFAULTNETWORKSTRING]\nconst DEFAULTEXPIRETIME = 3600\nconst DEFAULTCLTVEXPIRY = 9\nconst DEFAULTDESCRIPTION = ''\n\nconst VALIDWITNESSVERSIONS = [0]\n\nconst BECH32CODES = {\n  bc: 'bitcoin',\n  tb: 'testnet',\n  bcrt: 'regtest',\n  sb: 'simnet',\n  ltc: 'litecoin',\n  tltc: 'litecoin_testnet'\n}\n\nconst DIVISORS = {\n  m: new BN(1e3, 10),\n  u: new BN(1e6, 10),\n  n: new BN(1e9, 10),\n  p: new BN(1e12, 10)\n}\n\nconst MAX_MILLISATS = new BN('2100000000000000000', 10)\n\nconst MILLISATS_PER_BTC = new BN(1e11, 10)\nconst MILLISATS_PER_MILLIBTC = new BN(1e8, 10)\nconst MILLISATS_PER_MICROBTC = new BN(1e5, 10)\nconst MILLISATS_PER_NANOBTC = new BN(1e2, 10)\nconst PICOBTC_PER_MILLISATS = new BN(10, 10)\n\nconst TAGCODES = {\n  payment_hash: 1,\n  description: 13,\n  payee_node_key: 19,\n  purpose_commit_hash: 23, // commit to longer descriptions (like a website)\n  expire_time: 6, // default: 3600 (1 hour)\n  min_final_cltv_expiry: 24, // default: 9\n  fallback_address: 9,\n  routing_info: 3 // for extra routing info (private etc.)\n}\n\n// reverse the keys and values of TAGCODES and insert into TAGNAMES\nconst TAGNAMES = {}\nfor (let i = 0, keys = Object.keys(TAGCODES); i < keys.length; i++) {\n  let currentName = keys[i]\n  let currentCode = TAGCODES[keys[i]].toString()\n  TAGNAMES[currentCode] = currentName\n}\n\nconst TAGENCODERS = {\n  payment_hash: hexToWord, // 256 bits\n  description: textToWord, // string variable length\n  payee_node_key: hexToWord, // 264 bits\n  purpose_commit_hash: purposeCommitEncoder, // 256 bits\n  expire_time: intBEToWords, // default: 3600 (1 hour)\n  min_final_cltv_expiry: intBEToWords, // default: 9\n  fallback_address: fallbackAddressEncoder,\n  routing_info: routingInfoEncoder // for extra routing info (private etc.)\n}\n\nconst TAGPARSERS = {\n  '1': (words) => wordsToBuffer(words, true).toString('hex'), // 256 bits\n  '13': (words) => wordsToBuffer(words, true).toString('utf8'), // string variable length\n  '19': (words) => wordsToBuffer(words, true).toString('hex'), // 264 bits\n  '23': (words) => wordsToBuffer(words, true).toString('hex'), // 256 bits\n  '6': wordsToIntBE, // default: 3600 (1 hour)\n  '24': wordsToIntBE, // default: 9\n  '9': fallbackAddressParser,\n  '3': routingInfoParser // for extra routing info (private etc.)\n}\n\nconst unknownTagName = 'unknownTag'\n\nfunction unknownEncoder (data) {\n  data.words = bech32.decode(data.words, Number.MAX_SAFE_INTEGER).words\n  return data\n}\n\nfunction getUnknownParser (tagCode) {\n  return (words) => ({\n    tagCode: parseInt(tagCode),\n    words: bech32.encode('unknown', words, Number.MAX_SAFE_INTEGER)\n  })\n}\n\nfunction wordsToIntBE (words) {\n  return words.reverse().reduce((total, item, index) => {\n    return total + item * Math.pow(32, index)\n  }, 0)\n}\n\nfunction intBEToWords (intBE, bits) {\n  let words = []\n  if (bits === undefined) bits = 5\n  intBE = Math.floor(intBE)\n  if (intBE === 0) return [0]\n  while (intBE > 0) {\n    words.push(intBE & (Math.pow(2, bits) - 1))\n    intBE = Math.floor(intBE / Math.pow(2, bits))\n  }\n  return words.reverse()\n}\n\nfunction sha256 (data) {\n  return crypto.createHash('sha256').update(data).digest()\n}\n\nfunction convert (data, inBits, outBits) {\n  let value = 0\n  let bits = 0\n  let maxV = (1 << outBits) - 1\n\n  let result = []\n  for (let i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (bits > 0) {\n    result.push((value << (outBits - bits)) & maxV)\n  }\n\n  return result\n}\n\nfunction wordsToBuffer (words, trim) {\n  let buffer = Buffer.from(convert(words, 5, 8, true))\n  if (trim && words.length * 5 % 8 !== 0) {\n    buffer = buffer.slice(0, -1)\n  }\n  return buffer\n}\n\nfunction hexToBuffer (hex) {\n  if (hex !== undefined &&\n      (typeof hex === 'string' || hex instanceof String) &&\n      hex.match(/^([a-zA-Z0-9]{2})*$/)) {\n    return Buffer.from(hex, 'hex')\n  }\n  return hex\n}\n\nfunction textToBuffer (text) {\n  return Buffer.from(text, 'utf8')\n}\n\nfunction hexToWord (hex) {\n  let buffer = hexToBuffer(hex)\n  return bech32.toWords(buffer)\n}\n\nfunction textToWord (text) {\n  let buffer = textToBuffer(text)\n  let words = bech32.toWords(buffer)\n  return words\n}\n\n// see encoder for details\nfunction fallbackAddressParser (words, network) {\n  let version = words[0]\n  words = words.slice(1)\n\n  let addressHash = wordsToBuffer(words, true)\n\n  let address = null\n\n  switch (version) {\n    case 17:\n      address = bitcoinjsAddress.toBase58Check(addressHash, network.pubKeyHash)\n      break\n    case 18:\n      address = bitcoinjsAddress.toBase58Check(addressHash, network.scriptHash)\n      break\n    case 0:\n      address = bitcoinjsAddress.toBech32(addressHash, version, network.bech32)\n      break\n  }\n\n  return {\n    code: version,\n    address,\n    addressHash: addressHash.toString('hex')\n  }\n}\n\n// the code is the witness version OR 17 for P2PKH OR 18 for P2SH\n// anything besides code 17 or 18 should be bech32 encoded address.\n// 1 word for the code, and right pad with 0 if necessary for the addressHash\n// (address parsing for encode is done in the encode function)\nfunction fallbackAddressEncoder (data, network) {\n  return [data.code].concat(hexToWord(data.addressHash))\n}\n\n// first convert from words to buffer, trimming padding where necessary\n// parse in 51 byte chunks. See encoder for details.\nfunction routingInfoParser (words) {\n  let routes = []\n  let pubkey, shortChannelId, feeBaseMSats, feeProportionalMillionths, cltvExpiryDelta\n  let routesBuffer = wordsToBuffer(words, true)\n  while (routesBuffer.length > 0) {\n    pubkey = routesBuffer.slice(0, 33).toString('hex') // 33 bytes\n    shortChannelId = routesBuffer.slice(33, 41).toString('hex') // 8 bytes\n    feeBaseMSats = parseInt(routesBuffer.slice(41, 45).toString('hex'), 16) // 4 bytes\n    feeProportionalMillionths = parseInt(routesBuffer.slice(45, 49).toString('hex'), 16) // 4 bytes\n    cltvExpiryDelta = parseInt(routesBuffer.slice(49, 51).toString('hex'), 16) // 2 bytes\n\n    routesBuffer = routesBuffer.slice(51)\n\n    routes.push({\n      pubkey,\n      short_channel_id: shortChannelId,\n      fee_base_msat: feeBaseMSats,\n      fee_proportional_millionths: feeProportionalMillionths,\n      cltv_expiry_delta: cltvExpiryDelta\n    })\n  }\n  return routes\n}\n\n// routing info is encoded first as a large buffer\n// 51 bytes for each channel\n// 33 byte pubkey, 8 byte short_channel_id, 4 byte millisatoshi base fee (left padded)\n// 4 byte fee proportional millionths and a 2 byte left padded CLTV expiry delta.\n// after encoding these 51 byte chunks and concatenating them\n// convert to words right padding 0 bits.\nfunction routingInfoEncoder (datas) {\n  let buffer = Buffer.from([])\n  datas.forEach(data => {\n    buffer = Buffer.concat([buffer, hexToBuffer(data.pubkey)])\n    buffer = Buffer.concat([buffer, hexToBuffer(data.short_channel_id)])\n    buffer = Buffer.concat([buffer, Buffer.from([0, 0, 0].concat(intBEToWords(data.fee_base_msat, 8)).slice(-4))])\n    buffer = Buffer.concat([buffer, Buffer.from([0, 0, 0].concat(intBEToWords(data.fee_proportional_millionths, 8)).slice(-4))])\n    buffer = Buffer.concat([buffer, Buffer.from([0].concat(intBEToWords(data.cltv_expiry_delta, 8)).slice(-2))])\n  })\n  return hexToWord(buffer)\n}\n\n// if text, return the sha256 hash of the text as words.\n// if hex, return the words representation of that data.\nfunction purposeCommitEncoder (data) {\n  let buffer\n  if (data !== undefined && (typeof data === 'string' || data instanceof String)) {\n    if (data.match(/^([a-zA-Z0-9]{2})*$/)) {\n      buffer = Buffer.from(data, 'hex')\n    } else {\n      buffer = sha256(Buffer.from(data, 'utf8'))\n    }\n  } else {\n    throw new Error('purpose or purpose commit must be a string or hex string')\n  }\n  return bech32.toWords(buffer)\n}\n\nfunction tagsItems (tags, tagName) {\n  let tag = tags.filter(item => item.tagName === tagName)\n  let data = tag.length > 0 ? tag[0].data : null\n  return data\n}\n\nfunction tagsContainItem (tags, tagName) {\n  return tagsItems(tags, tagName) !== null\n}\n\nfunction orderKeys (unorderedObj) {\n  let orderedObj = {}\n  Object.keys(unorderedObj).sort().forEach((key) => {\n    orderedObj[key] = unorderedObj[key]\n  })\n  return orderedObj\n}\n\nfunction satToHrp (satoshis) {\n  if (!satoshis.toString().match(/^\\d+$/)) {\n    throw new Error('satoshis must be an integer')\n  }\n  let millisatoshisBN = new BN(satoshis, 10)\n  return millisatToHrp(millisatoshisBN.mul(new BN(1000, 10)))\n}\n\nfunction millisatToHrp (millisatoshis) {\n  if (!millisatoshis.toString().match(/^\\d+$/)) {\n    throw new Error('millisatoshis must be an integer')\n  }\n  let millisatoshisBN = new BN(millisatoshis, 10)\n  let millisatoshisString = millisatoshisBN.toString(10)\n  let millisatoshisLength = millisatoshisString.length\n  let divisorString, valueString\n  if (millisatoshisLength > 11 && /0{11}$/.test(millisatoshisString)) {\n    divisorString = ''\n    valueString = millisatoshisBN.div(MILLISATS_PER_BTC).toString(10)\n  } else if (millisatoshisLength > 8 && /0{8}$/.test(millisatoshisString)) {\n    divisorString = 'm'\n    valueString = millisatoshisBN.div(MILLISATS_PER_MILLIBTC).toString(10)\n  } else if (millisatoshisLength > 5 && /0{5}$/.test(millisatoshisString)) {\n    divisorString = 'u'\n    valueString = millisatoshisBN.div(MILLISATS_PER_MICROBTC).toString(10)\n  } else if (millisatoshisLength > 2 && /0{2}$/.test(millisatoshisString)) {\n    divisorString = 'n'\n    valueString = millisatoshisBN.div(MILLISATS_PER_NANOBTC).toString(10)\n  } else {\n    divisorString = 'p'\n    valueString = millisatoshisBN.mul(PICOBTC_PER_MILLISATS).toString(10)\n  }\n  return valueString + divisorString\n}\n\nfunction hrpToSat (hrpString, outputString) {\n  let millisatoshisBN = hrpToMillisat(hrpString, false)\n  if (!millisatoshisBN.mod(new BN(1000, 10)).eq(new BN(0, 10))) {\n    throw new Error('Amount is outside of valid range')\n  }\n  let result = millisatoshisBN.div(new BN(1000, 10))\n  return outputString ? result.toString() : result\n}\n\nfunction hrpToMillisat (hrpString, outputString) {\n  let divisor, value\n  if (hrpString.slice(-1).match(/^[munp]$/)) {\n    divisor = hrpString.slice(-1)\n    value = hrpString.slice(0, -1)\n  } else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {\n    throw new Error('Not a valid multiplier for the amount')\n  } else {\n    value = hrpString\n  }\n\n  if (!value.match(/^\\d+$/)) throw new Error('Not a valid human readable amount')\n\n  let valueBN = new BN(value, 10)\n\n  let millisatoshisBN = divisor\n    ? valueBN.mul(MILLISATS_PER_BTC).div(DIVISORS[divisor])\n    : valueBN.mul(MILLISATS_PER_BTC)\n\n  if (((divisor === 'p' && !valueBN.mod(new BN(10, 10)).eq(new BN(0, 10))) ||\n      millisatoshisBN.gt(MAX_MILLISATS))) {\n    throw new Error('Amount is outside of valid range')\n  }\n\n  return outputString ? millisatoshisBN.toString() : millisatoshisBN\n}\n\nfunction sign (inputPayReqObj, inputPrivateKey) {\n  let payReqObj = cloneDeep(inputPayReqObj)\n  let privateKey = hexToBuffer(inputPrivateKey)\n  if (payReqObj.complete && payReqObj.paymentRequest) return payReqObj\n\n  if (privateKey === undefined || privateKey.length !== 32 ||\n      !secp256k1.privateKeyVerify(privateKey)) {\n    throw new Error('privateKey must be a 32 byte Buffer and valid private key')\n  }\n\n  let nodePublicKey, tagNodePublicKey\n  // If there is a payee_node_key tag convert to buffer\n  if (tagsContainItem(payReqObj.tags, TAGNAMES['19'])) {\n    tagNodePublicKey = hexToBuffer(tagsItems(payReqObj.tags, TAGNAMES['19']))\n  }\n  // If there is payeeNodeKey attribute, convert to buffer\n  if (payReqObj.payeeNodeKey) {\n    nodePublicKey = hexToBuffer(payReqObj.payeeNodeKey)\n  }\n  // If they are not equal throw an error\n  if (nodePublicKey && tagNodePublicKey && !tagNodePublicKey.equals(nodePublicKey)) {\n    throw new Error('payee node key tag and payeeNodeKey attribute must match')\n  }\n\n  // make sure if either exist they are in nodePublicKey\n  nodePublicKey = tagNodePublicKey || nodePublicKey\n\n  let publicKey = secp256k1.publicKeyCreate(privateKey)\n\n  // Check if pubkey matches for private key\n  if (nodePublicKey && !publicKey.equals(nodePublicKey)) {\n    throw new Error('The private key given is not the private key of the node public key given')\n  }\n\n  let words = bech32.decode(payReqObj.wordsTemp, Number.MAX_SAFE_INTEGER).words\n\n  // the preimage for the signing data is the buffer of the prefix concatenated\n  // with the buffer conversion of the data words excluding the signature\n  // (right padded with 0 bits)\n  let toSign = Buffer.concat([Buffer.from(payReqObj.prefix, 'utf8'), wordsToBuffer(words)])\n  // single SHA256 hash for the signature\n  let payReqHash = sha256(toSign)\n\n  // signature is 64 bytes (32 byte r value and 32 byte s value concatenated)\n  // PLUS one extra byte appended to the right with the recoveryID in [0,1,2,3]\n  // Then convert to 5 bit words with right padding 0 bits.\n  let sigObj = secp256k1.sign(payReqHash, privateKey)\n  let sigWords = hexToWord(sigObj.signature.toString('hex') + '0' + sigObj.recovery)\n\n  // append signature words to the words, mark as complete, and add the payreq\n  payReqObj.payeeNodeKey = publicKey.toString('hex')\n  payReqObj.signature = sigObj.signature.toString('hex')\n  payReqObj.recoveryFlag = sigObj.recovery\n  payReqObj.wordsTemp = bech32.encode('temp', words.concat(sigWords), Number.MAX_SAFE_INTEGER)\n  payReqObj.complete = true\n  payReqObj.paymentRequest = bech32.encode(payReqObj.prefix, words.concat(sigWords), Number.MAX_SAFE_INTEGER)\n\n  return orderKeys(payReqObj)\n}\n\n/* MUST but default OK:\n  coinType  (default: testnet OK)\n  timestamp   (default: current time OK)\n\n  MUST:\n  signature OR privatekey\n  tags[TAGNAMES['1']] (payment hash)\n  tags[TAGNAMES['13']] OR tags[TAGNAMES['23']] (description or description for hashing (or description hash))\n\n  MUST CHECK:\n  IF tags[TAGNAMES['19']] (payee_node_key) THEN MUST CHECK THAT PUBKEY = PUBKEY OF PRIVATEKEY / SIGNATURE\n  IF tags[TAGNAMES['9']] (fallback_address) THEN MUST CHECK THAT THE ADDRESS IS A VALID TYPE\n  IF tags[TAGNAMES['3']] (routing_info) THEN MUST CHECK FOR ALL INFO IN EACH\n*/\nfunction encode (inputData, addDefaults) {\n  // we don't want to affect the data being passed in, so we copy the object\n  let data = cloneDeep(inputData)\n\n  // by default we will add default values to description, expire time, and min cltv\n  if (addDefaults === undefined) addDefaults = true\n\n  let canReconstruct = !(data.signature === undefined || data.recoveryFlag === undefined)\n\n  // if no cointype is defined, set to testnet\n  let coinTypeObj\n  if (data.coinType === undefined && !canReconstruct) {\n    data.coinType = DEFAULTNETWORKSTRING\n    coinTypeObj = DEFAULTNETWORK\n  } else if (data.coinType === undefined && canReconstruct) {\n    throw new Error('Need coinType for proper payment request reconstruction')\n  } else {\n    // if the coinType is not a valid name of a network in bitcoinjs-lib, fail\n    if (!BITCOINJS_NETWORK_INFO[data.coinType]) throw new Error('Unknown coin type')\n    coinTypeObj = BITCOINJS_NETWORK_INFO[data.coinType]\n  }\n\n  // use current time as default timestamp (seconds)\n  if (data.timestamp === undefined && !canReconstruct) {\n    data.timestamp = Math.floor(new Date().getTime() / 1000)\n  } else if (data.timestamp === undefined && canReconstruct) {\n    throw new Error('Need timestamp for proper payment request reconstruction')\n  }\n\n  if (data.tags === undefined) throw new Error('Payment Requests need tags array')\n\n  // If no payment hash, fail\n  if (!tagsContainItem(data.tags, TAGNAMES['1'])) {\n    throw new Error('Lightning Payment Request needs a payment hash')\n  }\n  // If no description or purpose commit hash/message, fail\n  if (!tagsContainItem(data.tags, TAGNAMES['13']) && !tagsContainItem(data.tags, TAGNAMES['23'])) {\n    if (addDefaults) {\n      data.tags.push({\n        tagName: TAGNAMES['13'],\n        data: DEFAULTDESCRIPTION\n      })\n    } else {\n      throw new Error('Payment request requires description or purpose commit hash')\n    }\n  }\n\n  // If a description exists, check to make sure the buffer isn't greater than\n  // 639 bytes long, since 639 * 8 / 5 = 1023 words (5 bit) when padded\n  if (tagsContainItem(data.tags, TAGNAMES['13']) &&\n      Buffer.from(tagsItems(data.tags, TAGNAMES['13']), 'utf8').length > 639) {\n    throw new Error('Description is too long: Max length 639 bytes')\n  }\n\n  // if there's no expire time, and it is not reconstructing (must have private key)\n  // default to adding a 3600 second expire time (1 hour)\n  if (!tagsContainItem(data.tags, TAGNAMES['6']) && !canReconstruct && addDefaults) {\n    data.tags.push({\n      tagName: TAGNAMES['6'],\n      data: DEFAULTEXPIRETIME\n    })\n  }\n\n  // if there's no minimum cltv time, and it is not reconstructing (must have private key)\n  // default to adding a 9 block minimum cltv time (90 minutes for bitcoin)\n  if (!tagsContainItem(data.tags, TAGNAMES['24']) && !canReconstruct && addDefaults) {\n    data.tags.push({\n      tagName: TAGNAMES['24'],\n      data: DEFAULTCLTVEXPIRY\n    })\n  }\n\n  let nodePublicKey, tagNodePublicKey\n  // If there is a payee_node_key tag convert to buffer\n  if (tagsContainItem(data.tags, TAGNAMES['19'])) tagNodePublicKey = hexToBuffer(tagsItems(data.tags, TAGNAMES['19']))\n  // If there is payeeNodeKey attribute, convert to buffer\n  if (data.payeeNodeKey) nodePublicKey = hexToBuffer(data.payeeNodeKey)\n  if (nodePublicKey && tagNodePublicKey && !tagNodePublicKey.equals(nodePublicKey)) {\n    throw new Error('payeeNodeKey and tag payee node key do not match')\n  }\n  // in case we have one or the other, make sure it's in nodePublicKey\n  nodePublicKey = nodePublicKey || tagNodePublicKey\n  if (nodePublicKey) data.payeeNodeKey = nodePublicKey.toString('hex')\n\n  let code, addressHash, address\n  // If there is a fallback address tag we must check it is valid\n  if (tagsContainItem(data.tags, TAGNAMES['9'])) {\n    let addrData = tagsItems(data.tags, TAGNAMES['9'])\n    // Most people will just provide address so Hash and code will be undefined here\n    address = addrData.address\n    addressHash = addrData.addressHash\n    code = addrData.code\n\n    if (addressHash === undefined || code === undefined) {\n      let bech32addr, base58addr\n      try {\n        bech32addr = bitcoinjsAddress.fromBech32(address)\n        addressHash = bech32addr.data\n        code = bech32addr.version\n      } catch (e) {\n        try {\n          base58addr = bitcoinjsAddress.fromBase58Check(address)\n          if (base58addr.version === coinTypeObj.pubKeyHash) {\n            code = 17\n          } else if (base58addr.version === coinTypeObj.scriptHash) {\n            code = 18\n          }\n          addressHash = base58addr.hash\n        } catch (f) {\n          throw new Error('Fallback address type is unknown')\n        }\n      }\n      if (bech32addr && !(bech32addr.version in VALIDWITNESSVERSIONS)) {\n        throw new Error('Fallback address witness version is unknown')\n      }\n      if (bech32addr && bech32addr.prefix !== coinTypeObj.bech32) {\n        throw new Error('Fallback address network type does not match payment request network type')\n      }\n      if (base58addr && base58addr.version !== coinTypeObj.pubKeyHash &&\n          base58addr.version !== coinTypeObj.scriptHash) {\n        throw new Error('Fallback address version (base58) is unknown or the network type is incorrect')\n      }\n\n      // FIXME: If addressHash or code is missing, add them to the original Object\n      // after parsing the address value... this changes the actual attributes of the data object.\n      // Not very clean.\n      // Without this, a person can not specify a fallback address tag with only the address key.\n      addrData.addressHash = addressHash.toString('hex')\n      addrData.code = code\n    }\n  }\n\n  // If there is route info tag, check that each route has all 4 necessary info\n  if (tagsContainItem(data.tags, TAGNAMES['3'])) {\n    let routingInfo = tagsItems(data.tags, TAGNAMES['3'])\n    routingInfo.forEach(route => {\n      if (route.pubkey === undefined ||\n        route.short_channel_id === undefined ||\n        route.fee_base_msat === undefined ||\n        route.fee_proportional_millionths === undefined ||\n        route.cltv_expiry_delta === undefined) {\n        throw new Error('Routing info is incomplete')\n      }\n      if (!secp256k1.publicKeyVerify(hexToBuffer(route.pubkey))) {\n        throw new Error('Routing info pubkey is not a valid pubkey')\n      }\n      let shortId = hexToBuffer(route.short_channel_id)\n      if (!(shortId instanceof Buffer) || shortId.length !== 8) {\n        throw new Error('Routing info short channel id must be 8 bytes')\n      }\n      if (typeof route.fee_base_msat !== 'number' ||\n        Math.floor(route.fee_base_msat) !== route.fee_base_msat) {\n        throw new Error('Routing info fee base msat is not an integer')\n      }\n      if (typeof route.fee_proportional_millionths !== 'number' ||\n        Math.floor(route.fee_proportional_millionths) !== route.fee_proportional_millionths) {\n        throw new Error('Routing info fee proportional millionths is not an integer')\n      }\n      if (typeof route.cltv_expiry_delta !== 'number' ||\n        Math.floor(route.cltv_expiry_delta) !== route.cltv_expiry_delta) {\n        throw new Error('Routing info cltv expiry delta is not an integer')\n      }\n    })\n  }\n\n  let prefix = 'ln'\n  prefix += coinTypeObj.bech32\n\n  let hrpString\n  // calculate the smallest possible integer (removing zeroes) and add the best\n  // divisor (m = milli, u = micro, n = nano, p = pico)\n  if (data.millisatoshis && data.satoshis) {\n    hrpString = millisatToHrp(new BN(data.millisatoshis, 10))\n    let hrpStringSat = satToHrp(new BN(data.satoshis, 10))\n    if (hrpStringSat !== hrpString) {\n      throw new Error('satoshis and millisatoshis do not match')\n    }\n  } else if (data.millisatoshis) {\n    hrpString = millisatToHrp(new BN(data.millisatoshis, 10))\n  } else if (data.satoshis) {\n    hrpString = satToHrp(new BN(data.satoshis, 10))\n  } else {\n    hrpString = ''\n  }\n\n  // bech32 human readable part is lnbc2500m (ln + coinbech32 + satoshis (optional))\n  // lnbc or lntb would be valid as well. (no value specified)\n  prefix += hrpString\n\n  // timestamp converted to 5 bit number array (left padded with 0 bits, NOT right padded)\n  let timestampWords = intBEToWords(data.timestamp)\n\n  let tags = data.tags\n  let tagWords = []\n  tags.forEach(tag => {\n    const possibleTagNames = Object.keys(TAGENCODERS)\n    if (canReconstruct) possibleTagNames.push(unknownTagName)\n    // check if the tagName exists in the encoders object, if not throw Error.\n    if (possibleTagNames.indexOf(tag.tagName) === -1) {\n      throw new Error('Unknown tag key: ' + tag.tagName)\n    }\n\n    let words\n    if (tag.tagName !== unknownTagName) {\n      // each tag starts with 1 word code for the tag\n      tagWords.push(TAGCODES[tag.tagName])\n\n      const encoder = TAGENCODERS[tag.tagName]\n      words = encoder(tag.data)\n    } else {\n      let result = unknownEncoder(tag.data)\n      tagWords.push(result.tagCode)\n      words = result.words\n    }\n    // after the tag code, 2 words are used to store the length (in 5 bit words) of the tag data\n    // (also left padded, most integers are left padded while buffers are right padded)\n    tagWords = tagWords.concat([0].concat(intBEToWords(words.length)).slice(-2))\n    // then append the tag data words\n    tagWords = tagWords.concat(words)\n  })\n\n  // the data part of the bech32 is TIMESTAMP || TAGS || SIGNATURE\n  // currently dataWords = TIMESTAMP || TAGS\n  let dataWords = timestampWords.concat(tagWords)\n\n  // the preimage for the signing data is the buffer of the prefix concatenated\n  // with the buffer conversion of the data words excluding the signature\n  // (right padded with 0 bits)\n  let toSign = Buffer.concat([Buffer.from(prefix, 'utf8'), Buffer.from(convert(dataWords, 5, 8))])\n  // single SHA256 hash for the signature\n  let payReqHash = sha256(toSign)\n\n  // signature is 64 bytes (32 byte r value and 32 byte s value concatenated)\n  // PLUS one extra byte appended to the right with the recoveryID in [0,1,2,3]\n  // Then convert to 5 bit words with right padding 0 bits.\n  let sigWords\n  if (canReconstruct) {\n    /* Since BOLT11 does not require a payee_node_key tag in the specs,\n    most parsers will have to recover the pubkey from the signature\n    To ensure the tag data has been provided in the right order etc.\n    we should check that the data we got and the node key given match when\n    reconstructing a payment request from given signature and recoveryID.\n    However, if a privatekey is given, the caller is the privkey owner.\n    Earlier we check if the private key matches the payee node key IF they\n    gave one. */\n    if (nodePublicKey) {\n      let recoveredPubkey = secp256k1.recover(payReqHash, Buffer.from(data.signature, 'hex'), data.recoveryFlag, true)\n      if (nodePublicKey && !nodePublicKey.equals(recoveredPubkey)) {\n        throw new Error('Signature, message, and recoveryID did not produce the same pubkey as payeeNodeKey')\n      }\n      sigWords = hexToWord(data.signature + '0' + data.recoveryFlag)\n    } else {\n      throw new Error('Reconstruction with signature and recoveryID requires payeeNodeKey to verify correctness of input data.')\n    }\n  }\n\n  if (sigWords) dataWords = dataWords.concat(sigWords)\n\n  if (tagsContainItem(data.tags, TAGNAMES['6'])) {\n    data.timeExpireDate = data.timestamp + tagsItems(data.tags, TAGNAMES['6'])\n    data.timeExpireDateString = new Date(data.timeExpireDate * 1000).toISOString()\n  }\n  data.timestampString = new Date(data.timestamp * 1000).toISOString()\n  data.paymentRequest = data.complete ? bech32.encode(prefix, dataWords, Number.MAX_SAFE_INTEGER) : ''\n  data.prefix = prefix\n  data.wordsTemp = bech32.encode('temp', dataWords, Number.MAX_SAFE_INTEGER)\n  data.complete = !!sigWords\n\n  // payment requests get pretty long. Nothing in the spec says anything about length.\n  // Even though bech32 loses error correction power over 1023 characters.\n  return orderKeys(data)\n}\n\n// decode will only have extra comments that aren't covered in encode comments.\n// also if anything is hard to read I'll comment.\nfunction decode (paymentRequest, network) {\n  if (typeof paymentRequest !== 'string') throw new Error('Lightning Payment Request must be string')\n  if (paymentRequest.slice(0, 2).toLowerCase() !== 'ln') throw new Error('Not a proper lightning payment request')\n  let decoded = bech32.decode(paymentRequest, Number.MAX_SAFE_INTEGER)\n  paymentRequest = paymentRequest.toLowerCase()\n  let prefix = decoded.prefix\n  let words = decoded.words\n\n  // signature is always 104 words on the end\n  // cutting off at the beginning helps since there's no way to tell\n  // ahead of time how many tags there are.\n  let sigWords = words.slice(-104)\n  // grabbing a copy of the words for later, words will be sliced as we parse.\n  let wordsNoSig = words.slice(0, -104)\n  words = words.slice(0, -104)\n\n  let sigBuffer = wordsToBuffer(sigWords, true)\n  let recoveryFlag = sigBuffer.slice(-1)[0]\n  sigBuffer = sigBuffer.slice(0, -1)\n\n  if (!(recoveryFlag in [0, 1, 2, 3]) || sigBuffer.length !== 64) {\n    throw new Error('Signature is missing or incorrect')\n  }\n\n  // Without reverse lookups, can't say that the multipier at the end must\n  // have a number before it, so instead we parse, and if the second group\n  // doesn't have anything, there's a good chance the last letter of the\n  // coin type got captured by the third group, so just re-regex without\n  // the number.\n  let prefixMatches = prefix.match(/^ln(\\S+?)(\\d*)([a-zA-Z]?)$/)\n  if (prefixMatches && !prefixMatches[2]) prefixMatches = prefix.match(/^ln(\\S+)$/)\n  if (!prefixMatches) {\n    throw new Error('Not a proper lightning payment request')\n  }\n\n  let bech32Prefix = prefixMatches[1]\n  let coinNetwork, coinType\n  if (BECH32CODES[bech32Prefix]) {\n    coinType = BECH32CODES[bech32Prefix]\n    coinNetwork = BITCOINJS_NETWORK_INFO[coinType]\n  } else if (network && network.bech32) {\n    coinType = 'unknown'\n    coinNetwork = network\n  }\n  if (!coinNetwork || coinNetwork.bech32 !== bech32Prefix) {\n    throw new Error('Unknown coin bech32 prefix')\n  }\n\n  let value = prefixMatches[2]\n  let satoshis, millisatoshis, removeSatoshis\n  if (value) {\n    let divisor = prefixMatches[3]\n    try {\n      satoshis = parseInt(hrpToSat(value + divisor, true))\n    } catch (e) {\n      satoshis = null\n      removeSatoshis = true\n    }\n    millisatoshis = hrpToMillisat(value + divisor, true)\n  } else {\n    satoshis = null\n    millisatoshis = null\n  }\n\n  // reminder: left padded 0 bits\n  let timestamp = wordsToIntBE(words.slice(0, 7))\n  let timestampString = new Date(timestamp * 1000).toISOString()\n  words = words.slice(7) // trim off the left 7 words\n\n  let tags = []\n  let tagName, parser, tagLength, tagWords\n  // we have no tag count to go on, so just keep hacking off words\n  // until we have none.\n  while (words.length > 0) {\n    let tagCode = words[0].toString()\n    tagName = TAGNAMES[tagCode] || unknownTagName\n    parser = TAGPARSERS[tagCode] || getUnknownParser(tagCode)\n    words = words.slice(1)\n\n    tagLength = wordsToIntBE(words.slice(0, 2))\n    words = words.slice(2)\n\n    tagWords = words.slice(0, tagLength)\n    words = words.slice(tagLength)\n\n    // See: parsers for more comments\n    tags.push({\n      tagName,\n      data: parser(tagWords, coinNetwork) // only fallback address needs coinNetwork\n    })\n  }\n\n  let timeExpireDate, timeExpireDateString\n  // be kind and provide an absolute expiration date.\n  // good for logs\n  if (tagsContainItem(tags, TAGNAMES['6'])) {\n    timeExpireDate = timestamp + tagsItems(tags, TAGNAMES['6'])\n    timeExpireDateString = new Date(timeExpireDate * 1000).toISOString()\n  }\n\n  let toSign = Buffer.concat([Buffer.from(prefix, 'utf8'), Buffer.from(convert(wordsNoSig, 5, 8))])\n  let payReqHash = sha256(toSign)\n  let sigPubkey = secp256k1.recover(payReqHash, sigBuffer, recoveryFlag, true)\n  if (tagsContainItem(tags, TAGNAMES['19']) && tagsItems(tags, TAGNAMES['19']) !== sigPubkey.toString('hex')) {\n    throw new Error('Lightning Payment Request signature pubkey does not match payee pubkey')\n  }\n\n  let finalResult = {\n    paymentRequest,\n    complete: true,\n    prefix,\n    wordsTemp: bech32.encode('temp', wordsNoSig.concat(sigWords), Number.MAX_SAFE_INTEGER),\n    coinType,\n    satoshis,\n    millisatoshis,\n    timestamp,\n    timestampString,\n    payeeNodeKey: sigPubkey.toString('hex'),\n    signature: sigBuffer.toString('hex'),\n    recoveryFlag,\n    tags\n  }\n\n  if (removeSatoshis) {\n    delete finalResult['satoshis']\n  }\n\n  if (timeExpireDate) {\n    finalResult = Object.assign(finalResult, {timeExpireDate, timeExpireDateString})\n  }\n\n  return orderKeys(finalResult)\n}\n\nmodule.exports = {\n  encode,\n  decode,\n  sign,\n  satToHrp,\n  millisatToHrp,\n  hrpToSat,\n  hrpToMillisat\n}\n","// BOLT11 Keys\nexport const COIN_TYPE_KEY = 'coinType';\nexport const COMPLETE_KEY = 'complete';\nexport const PAYEE_NODE_KEY = 'payeeNodeKey';\nexport const PAYMENT_REQUEST_KEY = 'paymentRequest';\nexport const PREFIX_KEY = 'prefix';\nexport const RECOVERY_FLAG_KEY = 'recoveryFlag';\nexport const SATOSHIS_KEY = 'satoshis';\nexport const MILLISATOSHIS_KEY = 'millisatoshis';\nexport const SIGNATURE_KEY = 'signature';\nexport const TIMESTAMP_KEY = 'timestamp';\nexport const TIMESTAMP_STRING_KEY = 'timestampString';\nexport const WORDS_TEMP_KEY = 'wordsTemp';\nexport const TAGS_KEY = 'tags';\nexport const COMMIT_HASH_KEY = 'purpose_commit_hash';\nexport const PAYMENT_HASH_KEY = 'payment_hash';\nexport const FALLBACK_ADDRESS_KEY = 'fallback_address';\nexport const CODE_KEY = 'code';\nexport const ADDRESS_KEY = 'address';\nexport const ADDRESS_HASH_KEY = 'addressHash';\nexport const DESCRIPTION_KEY = 'description';\nexport const EXPIRE_TIME = 'expire_time';\nexport const EXPIRY_HTLC = 'expiry_htlc';\nexport const MIN_FINAL_CLTV_EXPIRY = 'min_final_cltv_expiry';\nexport const TIME_EXPIRE_DATE_STRING = 'timeExpireDateString';\nexport const TIME_EXPIRE_DATE = 'timeExpireDate';\nexport const timeExpireDate = 'min_final_cltv_expiry';\nexport const UNKNOWN_TAG_KEY = 'unknownTag';\nexport const ROUTING_INFO_KEY = 'routing_info';\nexport const TAG_CODE_KEY = 'tagCode';\nexport const TAG_WORDS_KEY = 'words';\nexport const SHORT_CHANNEL_KEY = 'short_channel_id';\nexport const PUBKEY_KEY = 'pubkey';\nexport const FEE_PROPORTIONAL_KEY = 'fee_proportional_millionths';\nexport const FEE_BASE_MSAT_KEY = 'fee_base_msat';\nexport const CLTV_EXPIRY_DELTA_KEY = 'cltv_expiry_delta';\nexport const CALLBACK_KEY = 'callback';\nexport const COMMENT_ALLOWED_KEY = 'commentAllowed';\nexport const LNURL_TAG_KEY = 'tag';\nexport const LNURL_K1_KEY = 'k1';\nexport const DEFAULT_DESCRIPTION_KEY = 'defaultDescription';\nexport const LNURL_METADATA_KEY = 'metadata';\nexport const MIN_SENDABLE_KEY = 'minSendable';\nexport const MAX_SENDABLE_KEY = 'maxSendable';\nexport const MAX_WITHDRAWABLE_KEY = 'minWithdrawable';\nexport const MIN_WITHDRAWABLE_KEY = 'minWithdrawable';\nexport const LN_ADDRESS_DOMAIN_KEY = 'domain';\nexport const LN_ADDRESS_USERNAME_KEY = 'username';\n","// Key Formatting Utilities\nimport {\n  CODE_KEY,\n  PREFIX_KEY,\n  PUBKEY_KEY,\n  EXPIRE_TIME,\n  ADDRESS_KEY,\n  EXPIRY_HTLC,\n  SATOSHIS_KEY,\n  TAG_CODE_KEY,\n  CALLBACK_KEY,\n  LNURL_K1_KEY,\n  LNURL_TAG_KEY,\n  TAG_WORDS_KEY,\n  SIGNATURE_KEY,\n  COIN_TYPE_KEY,\n  TIMESTAMP_KEY,\n  WORDS_TEMP_KEY,\n  PAYEE_NODE_KEY,\n  DESCRIPTION_KEY,\n  COMMIT_HASH_KEY,\n  UNKNOWN_TAG_KEY,\n  MAX_SENDABLE_KEY,\n  MIN_SENDABLE_KEY,\n  ROUTING_INFO_KEY,\n  PAYMENT_HASH_KEY,\n  ADDRESS_HASH_KEY,\n  TIME_EXPIRE_DATE,\n  RECOVERY_FLAG_KEY,\n  MILLISATOSHIS_KEY,\n  FEE_BASE_MSAT_KEY,\n  SHORT_CHANNEL_KEY,\n  LNURL_METADATA_KEY,\n  COMMENT_ALLOWED_KEY,\n  PAYMENT_REQUEST_KEY,\n  MAX_WITHDRAWABLE_KEY,\n  MIN_WITHDRAWABLE_KEY,\n  FEE_PROPORTIONAL_KEY,\n  FALLBACK_ADDRESS_KEY,\n  TIMESTAMP_STRING_KEY,\n  MIN_FINAL_CLTV_EXPIRY,\n  CLTV_EXPIRY_DELTA_KEY,\n  LN_ADDRESS_DOMAIN_KEY,\n  LN_ADDRESS_USERNAME_KEY,\n  TIME_EXPIRE_DATE_STRING,\n  DEFAULT_DESCRIPTION_KEY,\n} from '../constants/keys';\n\nexport const formatDetailsKey = (key: string) => {\n  switch (key) {\n    case COIN_TYPE_KEY:\n      return 'Chain';\n    case PAYEE_NODE_KEY:\n      return 'Payee Pub Key';\n    case EXPIRE_TIME:\n      return 'Expire Time';\n    case PAYMENT_REQUEST_KEY:\n      return 'Invoice';\n    case PREFIX_KEY:\n      return 'Prefix';\n    case RECOVERY_FLAG_KEY:\n      return 'Recovery Flag';\n    case SATOSHIS_KEY:\n      return 'Amount (Satoshis)';\n    case MILLISATOSHIS_KEY:\n      return 'Amount (Millisatoshis)';\n    case SIGNATURE_KEY:\n      return 'Transaction Signature';\n    case TIMESTAMP_STRING_KEY:\n      return 'Timestamp String';\n    case WORDS_TEMP_KEY:\n      return 'Words Temp';\n    case COMMIT_HASH_KEY:\n      return 'Commit Hash';\n    case PAYMENT_HASH_KEY:\n      return 'Payment Hash';\n    case FALLBACK_ADDRESS_KEY:\n      return 'Fallback Address';\n    case ADDRESS_HASH_KEY:\n      return 'Address Hash';\n    case ADDRESS_KEY:\n      return 'Address';\n    case CODE_KEY:\n      return 'Code';\n    case DESCRIPTION_KEY:\n      return 'Description';\n    case EXPIRY_HTLC:\n      return 'Expiry CLTV';\n    case TIME_EXPIRE_DATE_STRING:\n      return 'Time Expire Date String';\n    case TIME_EXPIRE_DATE:\n      return 'Time Expire Date';\n    case TIMESTAMP_KEY:\n      return 'Timestamp';\n    case MIN_FINAL_CLTV_EXPIRY:\n      return 'Minimum Final CLTV Expiry';\n    case UNKNOWN_TAG_KEY:\n      return 'Unknown Tag';\n    case ROUTING_INFO_KEY:\n      return 'Routing Info';\n    case TAG_CODE_KEY:\n      return 'Tag Code';\n    case TAG_WORDS_KEY:\n      return 'Tag Words';\n    case CLTV_EXPIRY_DELTA_KEY:\n      return 'CLTV Expiry Delta';\n    case FEE_BASE_MSAT_KEY:\n      return 'Fee Base (MSats)';\n    case FEE_PROPORTIONAL_KEY:\n      return 'Tag Words';\n    case PUBKEY_KEY:\n      return 'Public Key';\n    case SHORT_CHANNEL_KEY:\n      return 'Short Channel ID';\n    case CALLBACK_KEY:\n      return 'Callback URL';\n    case COMMENT_ALLOWED_KEY:\n      return 'Comment Allowed (Chars)';\n    case MAX_SENDABLE_KEY:\n      return 'Max Sendable (MSats)';\n    case MIN_SENDABLE_KEY:\n      return 'Min Sendable (MSats)';\n    case MAX_WITHDRAWABLE_KEY:\n      return 'Max Withdrawable (MSats)';\n    case MIN_WITHDRAWABLE_KEY:\n      return 'Min Withdrawable (MSats)';\n    case LNURL_TAG_KEY:\n      return 'LNURL Tag/Type';\n    case LNURL_METADATA_KEY:\n      return 'LNURL Metadata';\n    case LNURL_K1_KEY:\n      return 'K1';\n    case DEFAULT_DESCRIPTION_KEY:\n      return 'Description';\n    case LN_ADDRESS_DOMAIN_KEY:\n      return 'Domain';\n    case LN_ADDRESS_USERNAME_KEY:\n      return 'Username';\n    default:\n      break;\n  }\n}\n","import bech32 from 'bech32';\nimport { Buffer } from 'buffer';\n\nimport { validateInternetIdentifier } from './internet-identifier';\nimport LightningPayReq from '../lib/bolt11';\n\nconst LIGHTNING_SCHEME = 'lightning';\nconst BOLT11_SCHEME = 'lnbc';\nconst LNURL_SCHEME = 'lnurl';\n\nexport const parseInvoice = async (invoice: string) => {\n  if (!invoice || invoice === '') {\n    return null;\n  }\n\n  const lcInvoice = invoice.trim().toLowerCase();\n  let requestCode = lcInvoice;\n\n  // Check if this is a Lightning Address\n  if (validateInternetIdentifier(requestCode)) {\n    const { success, data, message } = await handleLightningAddress(requestCode);\n\n    if (!success) {\n      return {\n        data: null,\n        error: message,\n        isLNURL: false,\n        isLNAddress: true,\n      };\n    }\n\n    return {\n      data,\n      isLNURL: true,\n      isLNAddress: true,\n    }\n  }\n\n  // Check if Invoice has `lightning` or `lnurl` prefixes\n  // (9 chars + the `:` or `=` chars) --> 10 characters total\n  const hasLightningPrefix = lcInvoice.indexOf(`${LIGHTNING_SCHEME}:`) !== -1;\n  if (hasLightningPrefix) {\n    // Remove the `lightning` prefix\n    requestCode = lcInvoice.slice(10, lcInvoice.length);\n  }\n\n  // (5 chars + the `:` or `=` chars) --> 6 characters total\n  const hasLNURLPrefix = lcInvoice.indexOf(`${LNURL_SCHEME}:`) !== -1;\n  if (hasLNURLPrefix) {\n    // Remove the `lightning` prefix\n    requestCode = lcInvoice.slice(6, lcInvoice.length);\n  }\n\n  // Parse LNURL or BOLT11\n  const isLNURL = requestCode.startsWith(LNURL_SCHEME);\n  if (isLNURL) {\n    return {\n      isLNURL: true,\n      data: handleLNURL(requestCode)\n    };\n  } else {\n    return {\n      isLNURL: false,\n      data: handleBOLT11(requestCode)\n    };\n  }\n};\n\nconst handleLNURL = (invoice: string) => {\n  // Decoding bech32 LNURL\n  const decodedLNURL = bech32.decode(invoice, 1500);\n  const url = Buffer.from(bech32.fromWords(decodedLNURL.words)).toString();\n\n  return fetch('https://satcors.fiatjaf.com/?url=' + encodeURIComponent(url))\n  .then(r => r.json())\n};\n\nconst handleLightningAddress = (internetIdentifier: string) => {\n  const addressArr = internetIdentifier.split('@');\n\n  // Must only have 2 fields (username and domain name)\n  if (addressArr.length !== 2) {\n    return {\n      success: false,\n      message: 'Invalid internet identifier format.',\n    };\n  }\n\n  const [username, domain] = addressArr;\n\n  // Must only have 2 fields (username and domain name)\n  if (addressArr[1].indexOf('.') === -1) {\n    return {\n      success: false,\n      message: 'Invalid internet identifier format.',\n    };\n  }\n\n  const url = `https://${domain}/.well-known/lnurlp/${username}`;\n\n  return fetch('https://satcors.fiatjaf.com/?url=' + encodeURIComponent(url))\n  .then(r => r.json())\n  .then(data => {\n    data.domain = domain;\n\n    return {\n      success: true,\n      data: {\n        ...data,\n        domain,\n        username,\n      },\n    }\n  }).catch(_ => {\n    return {\n      success: false,\n      message: 'This identifier does not support Lightning Address yet.',\n    };\n  });\n};\n\nconst handleBOLT11 = (invoice: string) => {\n  // Check if Invoice starts with `lnbc` prefix\n  if (!invoice.includes(BOLT11_SCHEME)) {\n    return null;\n  }\n\n  // Decoded BOLT11 Invoice\n  const result = LightningPayReq.decode(invoice);\n\n  return result;\n};\n\n","// Core Libs & Utils\nimport React, { PureComponent } from 'react';\nimport QrReader from 'react-qr-reader';\nimport cx from 'classnames';\n\n// Assets\nimport boltImage from './assets/images/bolt.png';\nimport arrowImage from './assets/images/arrow.svg';\nimport closeImage from './assets/images/close.svg';\nimport qrcodeImage from './assets/images/qrcode.png';\nimport githubImage from './assets/images/github.svg';\n\n// Utils\nimport { formatDetailsKey } from './utils/keys';\nimport { parseInvoice } from './utils/invoices';\n\n// Constants\nimport {\n  APP_NAME,\n  APP_GITHUB,\n  APP_TAGLINE,\n  APP_SUBTAGLINE,\n  APP_INPUT_PLACEHOLDER,\n} from './constants/app';\nimport {\n  TAGS_KEY,\n  COMPLETE_KEY,\n  LNURL_METADATA_KEY,\n  TIMESTAMP_STRING_KEY,\n  CALLBACK_KEY,\n  LNURL_TAG_KEY,\n} from './constants/keys';\n\n// Styles\nimport './assets/styles/main.scss';\n\nconst INITIAL_STATE = {\n  text: '',\n  error: {},\n  hasError: false,\n  decodedInvoice: {},\n  isLNAddress: false,\n  isQRCodeOpened: false,\n  isInvoiceLoaded: false,\n  isBitcoinAddrOpened: false,\n};\n\nexport class App extends PureComponent {\n  state = INITIAL_STATE;\n\n  componentDidMount() {\n    const invoiceOnURLParam = window.location.pathname;\n\n    // Remove first `/` from pathname\n    const cleanInvoice = invoiceOnURLParam.split('/')[1];\n    if (cleanInvoice && cleanInvoice !== '') {\n      this.setState(() => ({ text: cleanInvoice }));\n      this.getInvoiceDetails(cleanInvoice);\n    }\n  }\n\n  clearInvoiceDetails = () => {\n    // Reset URL address\n    const currentOrigin = window.location.origin;\n    window.history.pushState({}, null, `${currentOrigin}`);\n\n    this.setState(() => ({\n      ...INITIAL_STATE,\n    }));\n  };\n\n  getInvoiceDetails = async (text) => {\n    // If this returns null is because there is no invoice to parse\n    if (!text) {\n      return this.setState(() => ({\n        hasError: true,\n        decodedInvoice: {},\n        isInvoiceLoaded: false,\n        error: { message: 'Please enter a valid request or address and try again.'},\n      }));\n    }\n\n    try {\n      let response;\n      const parsedInvoiceResponse = await parseInvoice(text);\n\n      // If this returns null is because there is no invoice to parse\n      if (!parsedInvoiceResponse) {\n        return this.setState(() => ({\n          hasError: true,\n          decodedInvoice: {},\n          isInvoiceLoaded: false,\n          error: { message: 'Please enter a valid request or address and try again.'},\n        }));\n      }\n\n      const { isLNURL, data, error, isLNAddress } = parsedInvoiceResponse;\n\n      // If an error comes back from a nested operation in parsing it must\n      // propagate back to the end user\n      if (error && error.length > 0) {\n        return this.setState(() => ({\n          hasError: true,\n          decodedInvoice: {},\n          isInvoiceLoaded: false,\n          error: { message: error },\n        }));\n      }\n\n      // If data is null it means the parser could not understand the invoice\n      if (!data) {\n        return this.setState(() => ({\n          hasError: true,\n          decodedInvoice: {},\n          isInvoiceLoaded: false,\n          error: { message: 'Could not parse/understand this invoice or request. Please try again.'},\n        }));\n      }\n\n      // Handle LNURLs differently\n      if (isLNURL) {\n        // If this is a Lightning Address, the contents have already been fetched\n        if (isLNAddress) {\n          response = data;\n        } else {\n          // Otherwise this is an LNURL ready to be fetched\n          response = await data;\n        }\n      } else {\n        // Handle normal invoices\n        response = data;\n      }\n\n      if (response) {\n        // On successful response, set the request content on the addressbar\n        // if there isn't one already in there from before (user-entered)\n        const currentUrl = window.location;\n        const currentOrigin = window.location.origin;\n        const currentPathname = window.location.pathname;\n        const hasPathnameAlready = currentPathname && currentPathname !== '';\n\n        // If there's a pathname already, we can just remove it and let the\n        // new pathname be entered\n        if (hasPathnameAlready) {\n          window.history.pushState({}, null, `${currentOrigin}`);\n        }\n\n        window.history.pushState({}, null, `${currentUrl}${text}`);\n\n        this.setState(() => ({\n          isLNURL,\n          error: {},\n          isLNAddress,\n          hasError: false,\n          isInvoiceLoaded: true,\n          decodedInvoice: response,\n        }));\n      }\n    } catch(error) {\n      this.setState(() => ({\n        error: error,\n        hasError: true,\n        decodedInvoice: {},\n        isInvoiceLoaded: false,\n      }));\n    }\n  }\n\n  handleChange = (event) => {\n    const { target: { value: text } } = event;\n\n    this.setState(() => ({\n      text,\n      error: {},\n      hasError: false,\n    }));\n  }\n\n  handleKeyPress = (event) => {\n    const { text } = this.state;\n\n    if (event.key === 'Enter') {\n      this.getInvoiceDetails(text);\n    }\n  }\n\n  handleQRCode = () => this.setState(prevState => ({\n    isQRCodeOpened: !prevState.isQRCodeOpened\n  }))\n\n  renderErrorDetails = () => {\n    const { hasError, error } = this.state;\n\n    if (!hasError) return null;\n\n    return (\n      <div className='error'>\n        <div className='error__container'>\n          <div className='error__message'>\n            {error.message}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  renderInput = () => {\n    const { text } = this.state;\n\n    return (\n      <div className='input'>\n        <img\n          alt='Lightning'\n          src={boltImage}\n          className='input__asset'\n        />\n        <input\n          value={text}\n          className='input__text'\n          onChange={this.handleChange}\n          onKeyPress={this.handleKeyPress}\n          placeholder={APP_INPUT_PLACEHOLDER}\n          autoFocus\n        />\n      </div>\n    );\n  }\n\n  renderInvoiceDetails = () => {\n    const { decodedInvoice, isInvoiceLoaded } = this.state;\n    const invoiceContainerClassnames = cx(\n      'invoice',\n      { 'invoice--opened': isInvoiceLoaded },\n    );\n\n    const invoiceDetails = Object.keys(decodedInvoice)\n      .map((key) => {\n        switch (key) {\n          case COMPLETE_KEY:\n            return null;\n          case TAGS_KEY:\n            return this.renderInvoiceInnerItem(key);\n          case TIMESTAMP_STRING_KEY:\n            return this.renderInvoiceItem(\n              key,\n              TIMESTAMP_STRING_KEY,\n            );\n          default:\n            return this.renderInvoiceItem(key);\n        }\n      });\n\n    return !isInvoiceLoaded ? null : (\n      <div className={invoiceContainerClassnames}>\n        {invoiceDetails}\n      </div>\n    );\n  }\n\n  renderInvoiceInnerItem = (key) => {\n    const { decodedInvoice } = this.state;\n    const tags = decodedInvoice[key];\n\n    const renderTag = (tag) => (\n      typeof tag.data !== 'string' &&\n      typeof tag.data !== 'number'\n    ) ? renderNestedTag(tag) : renderNormalTag(tag);\n\n    const renderNestedItem = (label, value) => (\n      <div\n        key={label}\n        className='invoice__nested-item'\n      >\n        <div className='invoice__nested-title'>\n          {formatDetailsKey(label)}\n        </div>\n        <div className='invoice__nested-value'>\n          {value}\n        </div>\n      </div>\n    );\n\n    const renderNestedTag = (tag) => (\n      <div key={tag.tagName} className='invoice__item invoice__item--nested'>\n        <div className='invoice__item-title'>\n          {formatDetailsKey(tag.tagName)}\n        </div>\n        <div className='invoice__item-value invoice__item-value--nested'>\n          {/* Strings */}\n          {typeof tag.data === 'string' && (\n            <div className='invoice__nested-value'>\n              {tag.data}\n            </div>\n          )}\n          {/* Array of Objects */}\n          {Array.isArray(tag.data) && tag.data.map((item) => (\n            <>\n              {Object.keys(item).map((label) => renderNestedItem(label, item[label]))}\n            </>\n          ))}\n          {/* Objects */}\n          {(\n            !Array.isArray(tag.data) && (\n              (typeof tag.data !== 'string') || (typeof tag.data !== 'number'))\n            ) && (\n            <>\n              {Object.keys(tag.data).map((label) => renderNestedItem(label, tag.data[label]))}\n            </>\n          )}\n        </div>\n      </div>\n    );\n\n    const renderNormalTag = (tag) => (\n      <div key={tag.tagName} className='invoice__item'>\n        <div className='invoice__item-title'>\n          {formatDetailsKey(tag.tagName)}\n        </div>\n        <div className='invoice__item-value'>\n          {`${tag.data || '--'}`}\n        </div>\n      </div>\n    )\n\n    return tags.map((tag) => renderTag(tag));\n  }\n\n  renderInvoiceItem = (key, valuePropFormat) => {\n    const { decodedInvoice } = this.state;\n\n    let value = `${decodedInvoice[key]}`;\n    if (\n      valuePropFormat &&\n      valuePropFormat === TIMESTAMP_STRING_KEY\n    ) {\n      // TODO: this breaks\n      // value = `${formatTimestamp(decodedInvoice[key])}`;\n    }\n\n    return (\n      <div\n        key={key}\n        className='invoice__item'\n      >\n        <div className='invoice__item-title'>\n          {formatDetailsKey(key)}\n        </div>\n        <div className='invoice__item-value'>\n          {value}\n        </div>\n      </div>\n    );\n  }\n\n  renderLogo = () => (\n    <div className='logo'>\n      <div className='logo__title'>\n        {APP_NAME}\n      </div>\n      <div className='logo__subtitle'>\n        {APP_TAGLINE}\n        <span className=\"logo__subtitle-small\">{APP_SUBTAGLINE}</span>\n      </div>\n    </div>\n  );\n\n  renderLNURLDetails = () => {\n    const { decodedInvoice, isInvoiceLoaded } = this.state;\n    const invoiceContainerClassnames = cx(\n      'invoice',\n      { 'invoice--opened': isInvoiceLoaded },\n    );\n\n    let requestContents = decodedInvoice;\n\n    return !isInvoiceLoaded ? null : (\n      <div className={invoiceContainerClassnames}>\n        {Object.keys(requestContents).map((key) => {\n          let text = decodedInvoice[key];\n\n          if (key === 'status') {\n            return <></>\n          }\n\n          if (key === LNURL_TAG_KEY) {\n            switch (key) {\n              case 'payRequest':\n                text = 'LNURL Pay (payRequest)'\n                break;\n              case 'withdrawRequest':\n                text = 'LNURL Withdraw (withdrawRequest)'\n                break;\n              default:\n                break;\n            }\n\n            return (\n              <div key={`${key}-${Math.random()}`} className='invoice__item'>\n                <div className='invoice__item-title'>\n                  {formatDetailsKey(key)}\n                </div>\n                <div className='invoice__item-value'>\n                  <a href={decodedInvoice[key]}>\n                    {text}\n                  </a>\n                </div>\n              </div>\n            )\n          }\n\n          if (key === CALLBACK_KEY) {\n            return (\n              <div key={`${key}-${Math.random()}`} className='invoice__item'>\n                <div className='invoice__item-title'>\n                  {formatDetailsKey(key)}\n                </div>\n                <div className='invoice__item-value'>\n                  <a href={decodedInvoice[key]}>\n                    {decodedInvoice[key]}\n                  </a>\n                </div>\n              </div>\n            )\n          }\n\n          if (key === LNURL_METADATA_KEY) {\n            const splitMetadata = JSON.parse(decodedInvoice[key]);\n\n            // eslint-disable-next-line array-callback-return\n            const toRender = splitMetadata.map((arrOfData) => {\n              if (arrOfData[0] === 'text/plain') {\n                return (\n                  <div key={`${key}-${Math.random()}`} className='invoice__item'>\n                    <div className='invoice__item-title'>\n                      Description\n                    </div>\n                    <div className='invoice__item-value'>\n                      {arrOfData[1]}\n                    </div>\n                  </div>\n                )\n              }\n\n              if (arrOfData[0] === 'text/identifier') {\n                return (\n                  <div key={`${key}-${Math.random()}`} className='invoice__item'>\n                    <div className='invoice__item-title'>\n                      Lightning Address\n                    </div>\n                    <div className='invoice__item-value'>\n                      {arrOfData[1]}\n                    </div>\n                  </div>\n                )\n              }\n\n              if (arrOfData[0] === 'image/png;base64') {\n                return (\n                  <div key={`${key}-${Math.random()}`} className='invoice__item'>\n                    <div className='invoice__item-title'>\n                      Image\n                    </div>\n                    <div className='invoice__item-value'>\n                      <img\n                        alt='Imager'\n                        style={{ maxWidth: '200px' }}\n                        src={`data:image/png;base64,${arrOfData[1]}`}\n                      />\n                    </div>\n                  </div>\n                );\n              }\n            });\n\n            return toRender;\n          }\n\n          return (\n            <div key={`${key}-${Math.random()}`} className='invoice__item'>\n              <div className='invoice__item-title'>\n                {formatDetailsKey(key)}\n              </div>\n              <div className='invoice__item-value'>\n                {decodedInvoice[key]}\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n\n  renderSubmit = () => {\n    const { isInvoiceLoaded, text } = this.state;\n    const submitClassnames = cx(\n      'submit',\n      { 'submit__close': isInvoiceLoaded },\n    );\n\n    const onClick = () => {\n      if (isInvoiceLoaded) {\n        this.clearInvoiceDetails();\n      } else {\n        this.getInvoiceDetails(text);\n      }\n    }\n\n    return (\n      <div\n        onClick={onClick}\n        className={submitClassnames}\n      >\n        <img\n          alt='Submit'\n          src={isInvoiceLoaded ? closeImage : arrowImage}\n          className='submit__asset'\n        />\n      </div>\n    );\n  }\n\n  renderOptions = () => {\n    const { isInvoiceLoaded } = this.state;\n    const optionsClassnames = cx(\n      'options',\n      { 'options--hide': isInvoiceLoaded },\n    );\n\n    return (\n      <div className={optionsClassnames}>\n        <div className='options__wrapper'>\n          <a\n            href={APP_GITHUB}\n            className='options__github'\n            target='_blank'\n            rel='noopener noreferrer'\n          >\n            <img\n              className='options__github-icon'\n              src={githubImage}\n              alt='GitHub'\n            />\n          </a>\n        </div>\n      </div>\n    );\n  }\n\n  renderCamera = () => {\n    const { isQRCodeOpened, isInvoiceLoaded } = this.state;\n\n    const styleQRWrapper = cx({\n      'qrcode' : true,\n      'qrcode--opened': isQRCodeOpened,\n    });\n    const styleQRContainer = cx(\n      'qrcode__container',\n      { 'qrcode__container--opened': isQRCodeOpened },\n    );\n    const styleImgQR = cx(\n      'qrcode__img',\n      { 'qrcode__img--opened': isQRCodeOpened },\n    );\n\n    const qrReaderStyles = {\n      width: '100%',\n      border: '2pt solid #000000',\n    };\n\n    const srcImage = isQRCodeOpened ? closeImage : qrcodeImage;\n\n    const handleScan = (value) => {\n      if (Object.is(value, null)) return;\n\n      let text = value;\n      if (value.includes('lightning')) {\n        text = value.split('lightning:')[1];\n      }\n\n      this.getInvoiceDetails(text);\n      this.setState(() => ({\n        isQRCodeOpened: false,\n        text,\n      }));\n    }\n\n    const handleError = (error) => this.setState(() => ({\n      isInvoiceLoaded: false,\n      hasError: true,\n      error,\n      isQRCodeOpened: false\n    }));\n\n    return isInvoiceLoaded ? null : (\n      <div className={styleQRWrapper}>\n        {isQRCodeOpened && (\n          <div className='qrcode__modal' />\n        )}\n        <div className={styleQRContainer}>\n          <img\n            className={styleImgQR}\n            src={srcImage}\n            alt='QRCode'\n            onClick={this.handleQRCode}\n          />\n          {!isQRCodeOpened ? null : (\n            <QrReader\n              delay={300}\n              onError={handleError}\n              onScan={handleScan}\n              style={qrReaderStyles}\n            />\n          )}\n        </div>\n      </div>\n    );\n  }\n\n  render() {\n    const { isLNURL, isInvoiceLoaded, hasError } = this.state;\n\n    const appClasses = cx(\n      'app',\n      { 'app--opened': isInvoiceLoaded },\n    );\n    const appColumnClasses = cx(\n      'app__column',\n      {\n        'app__column--invoice-loaded': isInvoiceLoaded,\n        'app__column--error': hasError,\n      },\n    );\n    const appSubmitClasses = cx(\n      'app__submit',\n      { 'app__submit--invoice-loaded': isInvoiceLoaded },\n    );\n\n    return (\n      <div className={appClasses}>\n        {this.renderOptions()}\n        {this.renderLogo()}\n        <div className='app__row'>\n          {this.renderInput()}\n          <div className={appSubmitClasses}>\n            {this.renderSubmit()}\n            {this.renderCamera()}\n          </div>\n        </div>\n        <div className={appColumnClasses}>\n          {isLNURL ? this.renderLNURLDetails() : this.renderInvoiceDetails()}\n          {this.renderErrorDetails()}\n        </div>\n      </div>\n    );\n  }\n}\n","export const validateInternetIdentifier = (internetIdentifier) => {\n    var re = /\\S+@\\S+\\.\\S+/;\n    return re.test(internetIdentifier);\n}","// App-Wide Constants\nexport const APP_NAME = 'Lightning Decoder';\nexport const APP_TAGLINE = 'Decode Lightning Network Requests';\nexport const APP_SUBTAGLINE = 'BOLT11, LNURL, and Lightning Address'\nexport const APP_INPUT_PLACEHOLDER = 'Enter Invoice';\nexport const APP_GITHUB = 'https://github.com/j-chimienti/lightning-decoder';\n","// Core Libs\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\n// Main Component\nimport { App } from './app';\n\n// DOM Render\nReactDOM.render(\n  <App />,\n  document.getElementById('root'),\n);\n\n","module.exports = __webpack_public_path__ + \"static/media/close.3f436264.svg\";"],"sourceRoot":""}